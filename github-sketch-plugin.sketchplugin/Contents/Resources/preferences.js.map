{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./Resources/Portal.js","webpack:///./Resources/preferences.js","webpack:///./node_modules/preact/dist/preact.js","webpack:///./node_modules/sketch-module-web-view/client.js"],"names":["Portal","props","i","renderLayer","remote","parentNode","removeChild","node","document","querySelector","show","into","intoPointer","render","findNode","context","children","PortalProxy","Preferences","state","preferences","window","ready","interval","setInterval","setState","clearInterval","pluginCall","exportFolder","linkState","exportScale","exportFormat","diffByDefault","includeOverviewFile","autoExportOnSave","terminal","sendAnalytics","getElementById"],"mappings":"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,SAAL,CAAe,sBAAf;AAA7D,SACE;AAAQ,eAAM;AAAd,oBADF,EAEE;AAAQ,eAAM;AAAd,iBAFF,CAFF,CAvCF,EA8CE;AAAK,mBAAU;AAAf,SACE;AAAO,cAAK,UAAZ;AAAuB,iBAAST,YAAYgB,aAA5C;AAA2D,YAAG,eAA9D;AAA8E,kBAAU,KAAKP,SAAL,CAAe,2BAAf;AAAxF,QADF,EAEE;AAAO,iBAAQ;AAAf,0DAFF,CA9CF,CADF;AAqDD;;;;EA1EuB,gD;;AA6E1B,qDAAAhB,CAAO,oBAAC,WAAD,OAAP,EAAwBL,SAAS6B,cAAT,CAAwB,WAAxB,CAAxB,E;;;;;;;;;;;ACjFA;AACA,wCAA4M;AAC5M,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA,+FAA+F,KAAK,wBAAwB;AAC5H;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,2CAA2C,qBAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,kBAAkB,oBAAoB,gFAAgF;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iKAAiK;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAmE;AAChG;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,4DAA4D;AAC5D;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,kIAAkI,iCAAiC,iJAAiJ;AACpT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F;AAC7F,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAoD,iBAAiB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,2CAA2C,KAAK;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8IAA8I;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8IAA8I;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qJAAqJ;AACrJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kC;;;;;;;;;;;ACreA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"preferences.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./Resources/preferences.js\");\n","import { h, Component, render } from 'preact'\n\nexport default class Portal extends Component {\n  componentDidUpdate (props) {\n    for (let i in props) {\n      if (props[i] !== this.props[i]) {\n        return this.renderLayer()\n      }\n    }\n  }\n\n  componentDidMount () {\n    this.renderLayer()\n  }\n\n  componentWillUnmount () {\n    this.renderLayer(false)\n    if (this.remote) this.remote.parentNode.removeChild(this.remote)\n  }\n\n  findNode (node) {\n    return typeof node === 'string' ? document.querySelector(node) : node\n  }\n\n  renderLayer (show = true) {\n    const into = this.props.into || 'body'\n    // clean up old node if moving bases:\n    if (into !== this.intoPointer) {\n      this.intoPointer = into\n      if (this.into && this.remote) {\n        this.remote = render(<PortalProxy />, this.into, this.remote)\n      }\n      this.into = this.findNode(into)\n    }\n\n    this.remote = render((\n      <PortalProxy context={this.context}>\n        { (show && this.props.children) || null }\n      </PortalProxy>\n    ), this.into, this.remote)\n  }\n\n  render () {\n    return null\n  }\n}\n\n// high-order component that renders its first child if it exists.\n// used as a conditional rendering proxy.\nclass PortalProxy extends Component {\n  getChildContext () {\n    return this.props.context\n  }\n  render ({ children }) {\n    return (children && children[0]) || null\n  }\n}\n","import { h, render, Component } from 'preact'\nimport Portal from './Portal'\nimport pluginCall from 'sketch-module-web-view/client'\n\nclass Preferences extends Component {\n  constructor (props) {\n    super(props)\n    this.state = {\n      preferences: window.preferences || {},\n      ready: window.ready\n    }\n    if (!window.ready) {\n      const interval = setInterval(() => {\n        if (window.ready) {\n          this.setState({\n            preferences: window.preferences || {},\n            ready: window.ready\n          })\n          clearInterval(interval)\n        }\n      }, 100)\n    }\n  }\n\n  render (props, {ready, preferences}) {\n    return (\n      <div>\n        <Portal>\n          <button onClick={() => pluginCall('savePreferences', preferences)} className='save'>\n            Save Preferences\n          </button>\n        </Portal>\n        {!ready && 'loading...'}\n        <h2>Diffs preferences</h2>\n        <div className='form'>\n          <label htmlFor='folder'>Folder where the pretty diffs will be exported</label>\n          <input type='text' value={preferences.exportFolder} id='folder' onInput={this.linkState('preferences.exportFolder')} />\n        </div>\n        <div className='form'>\n          <label htmlFor='scale'>Scale of the exported artboards</label>\n          <input type='number' value={preferences.exportScale} id='scale' onInput={this.linkState('preferences.exportScale')} />\n        </div>\n        <div className='form'>\n          <label htmlFor='format'>Format of the exported artboards</label>\n          <select id='form' value={preferences.exportFormat} onChange={this.linkState('preferences.exportFormat')}>\n            <option value='png'>PNG</option>\n            <option value='jpg'>JPG</option>\n            <option value='pdf'>PDF</option>\n            <option value='eps'>EPS</option>\n            <option value='svg'>SVG</option>\n          </select>\n        </div>\n        <div className='form'>\n          <input type='checkbox' checked={preferences.diffByDefault} id='diffByDefault' onChange={this.linkState('preferences.diffByDefault')} />\n          <label htmlFor='diffByDefault'> Generate pretty diff by default</label>\n        </div>\n        <div className='form'>\n          <input type='checkbox' checked={preferences.includeOverviewFile} id='includeOverviewFile' onChange={this.linkState('preferences.includeOverviewFile')} />\n          <label htmlFor='includeOverviewFile'> Save an overview file with rendered artboards</label>\n        </div>\n        <div className='form'>\n          <input type='checkbox' checked={preferences.autoExportOnSave} id='autoExportOnSave' onChange={this.linkState('preferences.autoExportOnSave')} />\n          <label htmlFor='autoExportOnSave'> Auto export artboards on save</label>\n        </div>\n        <h2>Miscellaneous</h2>\n        <div className='form'>\n          <label htmlFor='terminal'>Terminal App</label>\n          <select id='terminal' value={preferences.terminal} onChange={this.linkState('preferences.terminal')}>\n            <option value='Terminal'>Terminal</option>\n            <option value='iTerm'>iTerm</option>\n          </select>\n        </div>\n        <div className='form'>\n          <input type='checkbox' checked={preferences.sendAnalytics} id='sendAnalytics' onChange={this.linkState('preferences.sendAnalytics')} />\n          <label htmlFor='sendAnalytics'> Send anymous usage data to improve the plugin</label>\n        </div>\n      </div>\n    )\n  }\n}\n\nrender(<Preferences />, document.getElementById('container'))\n","!function(global, factory) {\n    'object' == typeof exports && 'undefined' != typeof module ? factory(exports) : 'function' == typeof define && define.amd ? define([ 'exports' ], factory) : factory(global.preact = global.preact || {});\n}(this, function(exports) {\n    function VNode(nodeName, attributes, children) {\n        this.nodeName = nodeName;\n        this.attributes = attributes;\n        this.children = children;\n        this.key = attributes && attributes.key;\n    }\n    function h(nodeName, attributes) {\n        var children, lastSimple, child, simple, i;\n        for (i = arguments.length; i-- > 2; ) stack.push(arguments[i]);\n        if (attributes && attributes.children) {\n            if (!stack.length) stack.push(attributes.children);\n            delete attributes.children;\n        }\n        while (stack.length) if ((child = stack.pop()) instanceof Array) for (i = child.length; i--; ) stack.push(child[i]); else if (null != child && child !== !0 && child !== !1) {\n            if ('number' == typeof child) child = String(child);\n            simple = 'string' == typeof child;\n            if (simple && lastSimple) children[children.length - 1] += child; else {\n                (children || (children = [])).push(child);\n                lastSimple = simple;\n            }\n        }\n        var p = new VNode(nodeName, attributes || void 0, children || EMPTY_CHILDREN);\n        if (options.vnode) options.vnode(p);\n        return p;\n    }\n    function extend(obj, props) {\n        if (props) for (var i in props) obj[i] = props[i];\n        return obj;\n    }\n    function clone(obj) {\n        return extend({}, obj);\n    }\n    function delve(obj, key) {\n        for (var p = key.split('.'), i = 0; i < p.length && obj; i++) obj = obj[p[i]];\n        return obj;\n    }\n    function isFunction(obj) {\n        return 'function' == typeof obj;\n    }\n    function isString(obj) {\n        return 'string' == typeof obj;\n    }\n    function hashToClassName(c) {\n        var str = '';\n        for (var prop in c) if (c[prop]) {\n            if (str) str += ' ';\n            str += prop;\n        }\n        return str;\n    }\n    function cloneElement(vnode, props) {\n        return h(vnode.nodeName, extend(clone(vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);\n    }\n    function createLinkedState(component, key, eventPath) {\n        var path = key.split('.');\n        return function(e) {\n            var t = e && e.target || this, state = {}, obj = state, v = isString(eventPath) ? delve(e, eventPath) : t.nodeName ? t.type.match(/^che|rad/) ? t.checked : t.value : e, i = 0;\n            for (;i < path.length - 1; i++) obj = obj[path[i]] || (obj[path[i]] = !i && component.state[path[i]] || {});\n            obj[path[i]] = v;\n            component.setState(state);\n        };\n    }\n    function enqueueRender(component) {\n        if (!component._dirty && (component._dirty = !0) && 1 == items.push(component)) (options.debounceRendering || defer)(rerender);\n    }\n    function rerender() {\n        var p, list = items;\n        items = [];\n        while (p = list.pop()) if (p._dirty) renderComponent(p);\n    }\n    function isFunctionalComponent(vnode) {\n        var nodeName = vnode && vnode.nodeName;\n        return nodeName && isFunction(nodeName) && !(nodeName.prototype && nodeName.prototype.render);\n    }\n    function buildFunctionalComponent(vnode, context) {\n        return vnode.nodeName(getNodeProps(vnode), context || EMPTY);\n    }\n    function isSameNodeType(node, vnode) {\n        if (isString(vnode)) return node instanceof Text;\n        if (isString(vnode.nodeName)) return !node._componentConstructor && isNamedNode(node, vnode.nodeName);\n        if (isFunction(vnode.nodeName)) return (node._componentConstructor ? node._componentConstructor === vnode.nodeName : !0) || isFunctionalComponent(vnode); else return;\n    }\n    function isNamedNode(node, nodeName) {\n        return node.normalizedNodeName === nodeName || toLowerCase(node.nodeName) === toLowerCase(nodeName);\n    }\n    function getNodeProps(vnode) {\n        var props = clone(vnode.attributes);\n        props.children = vnode.children;\n        var defaultProps = vnode.nodeName.defaultProps;\n        if (defaultProps) for (var i in defaultProps) if (void 0 === props[i]) props[i] = defaultProps[i];\n        return props;\n    }\n    function removeNode(node) {\n        var p = node.parentNode;\n        if (p) p.removeChild(node);\n    }\n    function setAccessor(node, name, old, value, isSvg) {\n        if ('className' === name) name = 'class';\n        if ('class' === name && value && 'object' == typeof value) value = hashToClassName(value);\n        if ('key' === name) ; else if ('class' === name && !isSvg) node.className = value || ''; else if ('style' === name) {\n            if (!value || isString(value) || isString(old)) node.style.cssText = value || '';\n            if (value && 'object' == typeof value) {\n                if (!isString(old)) for (var i in old) if (!(i in value)) node.style[i] = '';\n                for (var i in value) node.style[i] = 'number' == typeof value[i] && !NON_DIMENSION_PROPS[i] ? value[i] + 'px' : value[i];\n            }\n        } else if ('dangerouslySetInnerHTML' === name) {\n            if (value) node.innerHTML = value.__html || '';\n        } else if ('o' == name[0] && 'n' == name[1]) {\n            var l = node._listeners || (node._listeners = {});\n            name = toLowerCase(name.substring(2));\n            if (value) {\n                if (!l[name]) node.addEventListener(name, eventProxy, !!NON_BUBBLING_EVENTS[name]);\n            } else if (l[name]) node.removeEventListener(name, eventProxy, !!NON_BUBBLING_EVENTS[name]);\n            l[name] = value;\n        } else if ('list' !== name && 'type' !== name && !isSvg && name in node) {\n            setProperty(node, name, null == value ? '' : value);\n            if (null == value || value === !1) node.removeAttribute(name);\n        } else {\n            var ns = isSvg && name.match(/^xlink\\:?(.+)/);\n            if (null == value || value === !1) if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1])); else node.removeAttribute(name); else if ('object' != typeof value && !isFunction(value)) if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', toLowerCase(ns[1]), value); else node.setAttribute(name, value);\n        }\n    }\n    function setProperty(node, name, value) {\n        try {\n            node[name] = value;\n        } catch (e) {}\n    }\n    function eventProxy(e) {\n        return this._listeners[e.type](options.event && options.event(e) || e);\n    }\n    function collectNode(node) {\n        removeNode(node);\n        if (node instanceof Element) {\n            node._component = node._componentConstructor = null;\n            var _name = node.normalizedNodeName || toLowerCase(node.nodeName);\n            (nodes[_name] || (nodes[_name] = [])).push(node);\n        }\n    }\n    function createNode(nodeName, isSvg) {\n        var name = toLowerCase(nodeName), node = nodes[name] && nodes[name].pop() || (isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName));\n        node.normalizedNodeName = name;\n        return node;\n    }\n    function flushMounts() {\n        var c;\n        while (c = mounts.pop()) {\n            if (options.afterMount) options.afterMount(c);\n            if (c.componentDidMount) c.componentDidMount();\n        }\n    }\n    function diff(dom, vnode, context, mountAll, parent, componentRoot) {\n        if (!diffLevel++) {\n            isSvgMode = parent && void 0 !== parent.ownerSVGElement;\n            hydrating = dom && !(ATTR_KEY in dom);\n        }\n        var ret = idiff(dom, vnode, context, mountAll);\n        if (parent && ret.parentNode !== parent) parent.appendChild(ret);\n        if (!--diffLevel) {\n            hydrating = !1;\n            if (!componentRoot) flushMounts();\n        }\n        return ret;\n    }\n    function idiff(dom, vnode, context, mountAll) {\n        var ref = vnode && vnode.attributes && vnode.attributes.ref;\n        while (isFunctionalComponent(vnode)) vnode = buildFunctionalComponent(vnode, context);\n        if (null == vnode) vnode = '';\n        if (isString(vnode)) {\n            if (dom && dom instanceof Text && dom.parentNode) {\n                if (dom.nodeValue != vnode) dom.nodeValue = vnode;\n            } else {\n                if (dom) recollectNodeTree(dom);\n                dom = document.createTextNode(vnode);\n            }\n            return dom;\n        }\n        if (isFunction(vnode.nodeName)) return buildComponentFromVNode(dom, vnode, context, mountAll);\n        var out = dom, nodeName = String(vnode.nodeName), prevSvgMode = isSvgMode, vchildren = vnode.children;\n        isSvgMode = 'svg' === nodeName ? !0 : 'foreignObject' === nodeName ? !1 : isSvgMode;\n        if (!dom) out = createNode(nodeName, isSvgMode); else if (!isNamedNode(dom, nodeName)) {\n            out = createNode(nodeName, isSvgMode);\n            while (dom.firstChild) out.appendChild(dom.firstChild);\n            if (dom.parentNode) dom.parentNode.replaceChild(out, dom);\n            recollectNodeTree(dom);\n        }\n        var fc = out.firstChild, props = out[ATTR_KEY];\n        if (!props) {\n            out[ATTR_KEY] = props = {};\n            for (var a = out.attributes, i = a.length; i--; ) props[a[i].name] = a[i].value;\n        }\n        if (!hydrating && vchildren && 1 === vchildren.length && 'string' == typeof vchildren[0] && fc && fc instanceof Text && !fc.nextSibling) {\n            if (fc.nodeValue != vchildren[0]) fc.nodeValue = vchildren[0];\n        } else if (vchildren && vchildren.length || fc) innerDiffNode(out, vchildren, context, mountAll, !!props.dangerouslySetInnerHTML);\n        diffAttributes(out, vnode.attributes, props);\n        if (ref) (props.ref = ref)(out);\n        isSvgMode = prevSvgMode;\n        return out;\n    }\n    function innerDiffNode(dom, vchildren, context, mountAll, absorb) {\n        var j, c, vchild, child, originalChildren = dom.childNodes, children = [], keyed = {}, keyedLen = 0, min = 0, len = originalChildren.length, childrenLen = 0, vlen = vchildren && vchildren.length;\n        if (len) for (var i = 0; i < len; i++) {\n            var _child = originalChildren[i], props = _child[ATTR_KEY], key = vlen ? (c = _child._component) ? c.__key : props ? props.key : null : null;\n            if (null != key) {\n                keyedLen++;\n                keyed[key] = _child;\n            } else if (hydrating || absorb || props || _child instanceof Text) children[childrenLen++] = _child;\n        }\n        if (vlen) for (var i = 0; i < vlen; i++) {\n            vchild = vchildren[i];\n            child = null;\n            var key = vchild.key;\n            if (null != key) {\n                if (keyedLen && key in keyed) {\n                    child = keyed[key];\n                    keyed[key] = void 0;\n                    keyedLen--;\n                }\n            } else if (!child && min < childrenLen) for (j = min; j < childrenLen; j++) {\n                c = children[j];\n                if (c && isSameNodeType(c, vchild)) {\n                    child = c;\n                    children[j] = void 0;\n                    if (j === childrenLen - 1) childrenLen--;\n                    if (j === min) min++;\n                    break;\n                }\n            }\n            child = idiff(child, vchild, context, mountAll);\n            if (child && child !== dom) if (i >= len) dom.appendChild(child); else if (child !== originalChildren[i]) {\n                if (child === originalChildren[i + 1]) removeNode(originalChildren[i]);\n                dom.insertBefore(child, originalChildren[i] || null);\n            }\n        }\n        if (keyedLen) for (var i in keyed) if (keyed[i]) recollectNodeTree(keyed[i]);\n        while (min <= childrenLen) {\n            child = children[childrenLen--];\n            if (child) recollectNodeTree(child);\n        }\n    }\n    function recollectNodeTree(node, unmountOnly) {\n        var component = node._component;\n        if (component) unmountComponent(component, !unmountOnly); else {\n            if (node[ATTR_KEY] && node[ATTR_KEY].ref) node[ATTR_KEY].ref(null);\n            if (!unmountOnly) collectNode(node);\n            var c;\n            while (c = node.lastChild) recollectNodeTree(c, unmountOnly);\n        }\n    }\n    function diffAttributes(dom, attrs, old) {\n        var name;\n        for (name in old) if (!(attrs && name in attrs) && null != old[name]) setAccessor(dom, name, old[name], old[name] = void 0, isSvgMode);\n        if (attrs) for (name in attrs) if (!('children' === name || 'innerHTML' === name || name in old && attrs[name] === ('value' === name || 'checked' === name ? dom[name] : old[name]))) setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);\n    }\n    function collectComponent(component) {\n        var name = component.constructor.name, list = components[name];\n        if (list) list.push(component); else components[name] = [ component ];\n    }\n    function createComponent(Ctor, props, context) {\n        var inst = new Ctor(props, context), list = components[Ctor.name];\n        Component.call(inst, props, context);\n        if (list) for (var i = list.length; i--; ) if (list[i].constructor === Ctor) {\n            inst.nextBase = list[i].nextBase;\n            list.splice(i, 1);\n            break;\n        }\n        return inst;\n    }\n    function setComponentProps(component, props, opts, context, mountAll) {\n        if (!component._disable) {\n            component._disable = !0;\n            if (component.__ref = props.ref) delete props.ref;\n            if (component.__key = props.key) delete props.key;\n            if (!component.base || mountAll) {\n                if (component.componentWillMount) component.componentWillMount();\n            } else if (component.componentWillReceiveProps) component.componentWillReceiveProps(props, context);\n            if (context && context !== component.context) {\n                if (!component.prevContext) component.prevContext = component.context;\n                component.context = context;\n            }\n            if (!component.prevProps) component.prevProps = component.props;\n            component.props = props;\n            component._disable = !1;\n            if (0 !== opts) if (1 === opts || options.syncComponentUpdates !== !1 || !component.base) renderComponent(component, 1, mountAll); else enqueueRender(component);\n            if (component.__ref) component.__ref(component);\n        }\n    }\n    function renderComponent(component, opts, mountAll, isChild) {\n        if (!component._disable) {\n            var skip, rendered, inst, cbase, props = component.props, state = component.state, context = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context, isUpdate = component.base, nextBase = component.nextBase, initialBase = isUpdate || nextBase, initialChildComponent = component._component;\n            if (isUpdate) {\n                component.props = previousProps;\n                component.state = previousState;\n                component.context = previousContext;\n                if (2 !== opts && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === !1) skip = !0; else if (component.componentWillUpdate) component.componentWillUpdate(props, state, context);\n                component.props = props;\n                component.state = state;\n                component.context = context;\n            }\n            component.prevProps = component.prevState = component.prevContext = component.nextBase = null;\n            component._dirty = !1;\n            if (!skip) {\n                if (component.render) rendered = component.render(props, state, context);\n                if (component.getChildContext) context = extend(clone(context), component.getChildContext());\n                while (isFunctionalComponent(rendered)) rendered = buildFunctionalComponent(rendered, context);\n                var toUnmount, base, childComponent = rendered && rendered.nodeName;\n                if (isFunction(childComponent)) {\n                    var childProps = getNodeProps(rendered);\n                    inst = initialChildComponent;\n                    if (inst && inst.constructor === childComponent && childProps.key == inst.__key) setComponentProps(inst, childProps, 1, context); else {\n                        toUnmount = inst;\n                        inst = createComponent(childComponent, childProps, context);\n                        inst.nextBase = inst.nextBase || nextBase;\n                        inst._parentComponent = component;\n                        component._component = inst;\n                        setComponentProps(inst, childProps, 0, context);\n                        renderComponent(inst, 1, mountAll, !0);\n                    }\n                    base = inst.base;\n                } else {\n                    cbase = initialBase;\n                    toUnmount = initialChildComponent;\n                    if (toUnmount) cbase = component._component = null;\n                    if (initialBase || 1 === opts) {\n                        if (cbase) cbase._component = null;\n                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, !0);\n                    }\n                }\n                if (initialBase && base !== initialBase && inst !== initialChildComponent) {\n                    var baseParent = initialBase.parentNode;\n                    if (baseParent && base !== baseParent) {\n                        baseParent.replaceChild(base, initialBase);\n                        if (!toUnmount) {\n                            initialBase._component = null;\n                            recollectNodeTree(initialBase);\n                        }\n                    }\n                }\n                if (toUnmount) unmountComponent(toUnmount, base !== initialBase);\n                component.base = base;\n                if (base && !isChild) {\n                    var componentRef = component, t = component;\n                    while (t = t._parentComponent) (componentRef = t).base = base;\n                    base._component = componentRef;\n                    base._componentConstructor = componentRef.constructor;\n                }\n            }\n            if (!isUpdate || mountAll) mounts.unshift(component); else if (!skip) {\n                if (component.componentDidUpdate) component.componentDidUpdate(previousProps, previousState, previousContext);\n                if (options.afterUpdate) options.afterUpdate(component);\n            }\n            var fn, cb = component._renderCallbacks;\n            if (cb) while (fn = cb.pop()) fn.call(component);\n            if (!diffLevel && !isChild) flushMounts();\n        }\n    }\n    function buildComponentFromVNode(dom, vnode, context, mountAll) {\n        var c = dom && dom._component, originalComponent = c, oldDom = dom, isDirectOwner = c && dom._componentConstructor === vnode.nodeName, isOwner = isDirectOwner, props = getNodeProps(vnode);\n        while (c && !isOwner && (c = c._parentComponent)) isOwner = c.constructor === vnode.nodeName;\n        if (c && isOwner && (!mountAll || c._component)) {\n            setComponentProps(c, props, 3, context, mountAll);\n            dom = c.base;\n        } else {\n            if (originalComponent && !isDirectOwner) {\n                unmountComponent(originalComponent, !0);\n                dom = oldDom = null;\n            }\n            c = createComponent(vnode.nodeName, props, context);\n            if (dom && !c.nextBase) {\n                c.nextBase = dom;\n                oldDom = null;\n            }\n            setComponentProps(c, props, 1, context, mountAll);\n            dom = c.base;\n            if (oldDom && dom !== oldDom) {\n                oldDom._component = null;\n                recollectNodeTree(oldDom);\n            }\n        }\n        return dom;\n    }\n    function unmountComponent(component, remove) {\n        if (options.beforeUnmount) options.beforeUnmount(component);\n        var base = component.base;\n        component._disable = !0;\n        if (component.componentWillUnmount) component.componentWillUnmount();\n        component.base = null;\n        var inner = component._component;\n        if (inner) unmountComponent(inner, remove); else if (base) {\n            if (base[ATTR_KEY] && base[ATTR_KEY].ref) base[ATTR_KEY].ref(null);\n            component.nextBase = base;\n            if (remove) {\n                removeNode(base);\n                collectComponent(component);\n            }\n            var c;\n            while (c = base.lastChild) recollectNodeTree(c, !remove);\n        }\n        if (component.__ref) component.__ref(null);\n        if (component.componentDidUnmount) component.componentDidUnmount();\n    }\n    function Component(props, context) {\n        this._dirty = !0;\n        this.context = context;\n        this.props = props;\n        if (!this.state) this.state = {};\n    }\n    function render(vnode, parent, merge) {\n        return diff(merge, vnode, {}, !1, parent);\n    }\n    var options = {};\n    var stack = [];\n    var EMPTY_CHILDREN = [];\n    var lcCache = {};\n    var toLowerCase = function(s) {\n        return lcCache[s] || (lcCache[s] = s.toLowerCase());\n    };\n    var resolved = 'undefined' != typeof Promise && Promise.resolve();\n    var defer = resolved ? function(f) {\n        resolved.then(f);\n    } : setTimeout;\n    var EMPTY = {};\n    var ATTR_KEY = 'undefined' != typeof Symbol ? Symbol.for('preactattr') : '__preactattr_';\n    var NON_DIMENSION_PROPS = {\n        boxFlex: 1,\n        boxFlexGroup: 1,\n        columnCount: 1,\n        fillOpacity: 1,\n        flex: 1,\n        flexGrow: 1,\n        flexPositive: 1,\n        flexShrink: 1,\n        flexNegative: 1,\n        fontWeight: 1,\n        lineClamp: 1,\n        lineHeight: 1,\n        opacity: 1,\n        order: 1,\n        orphans: 1,\n        strokeOpacity: 1,\n        widows: 1,\n        zIndex: 1,\n        zoom: 1\n    };\n    var NON_BUBBLING_EVENTS = {\n        blur: 1,\n        error: 1,\n        focus: 1,\n        load: 1,\n        resize: 1,\n        scroll: 1\n    };\n    var items = [];\n    var nodes = {};\n    var mounts = [];\n    var diffLevel = 0;\n    var isSvgMode = !1;\n    var hydrating = !1;\n    var components = {};\n    extend(Component.prototype, {\n        linkState: function(key, eventPath) {\n            var c = this._linkedStates || (this._linkedStates = {});\n            return c[key + eventPath] || (c[key + eventPath] = createLinkedState(this, key, eventPath));\n        },\n        setState: function(state, callback) {\n            var s = this.state;\n            if (!this.prevState) this.prevState = clone(s);\n            extend(s, isFunction(state) ? state(s, this.props) : state);\n            if (callback) (this._renderCallbacks = this._renderCallbacks || []).push(callback);\n            enqueueRender(this);\n        },\n        forceUpdate: function() {\n            renderComponent(this, 2);\n        },\n        render: function() {}\n    });\n    exports.h = h;\n    exports.cloneElement = cloneElement;\n    exports.Component = Component;\n    exports.render = render;\n    exports.rerender = rerender;\n    exports.options = options;\n});\n//# sourceMappingURL=preact.js.map","module.exports = function (actionName) {\n  if (!actionName) {\n    throw new Error('missing action name')\n  }\n  var args = [].slice.call(arguments).slice(1)\n  var previousHash = (window.location.hash.split('?')[1] ? window.location.hash.split('?')[0] : window.location.hash)\n  window.location.hash = previousHash +\n    '?pluginAction=' + encodeURIComponent(actionName) +\n    '&actionId=' + Date.now() +\n    '&pluginArgs=' + encodeURIComponent(JSON.stringify(args))\n  return\n}\n"],"sourceRoot":""}